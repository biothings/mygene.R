library(IRanges)
library(httr)
library(jsonlite)

<<<<<<< local
=======
version <- '0.3'
MyGene <- setClass("MyGene",
    slots=list(base.url="character", delay="numeric", step="numeric", agent="character"),
    prototype=list(base.url="http://mygene.info/v2", delay=1, step=1000, agent=sprintf('R-httr_mygene.R/httr.%s', version)))
>>>>>>> other

<<<<<<< local
version <- '0.3'
=======
validMyGeneObject <- function(object) {
    errors <- character(0)
    for (sn in c("base.url", "delay", "step", "agent")) {
        if (length(slot(object, sn)) != 1)
            errors <- c(errors, sprintf("Slot %s must have length 1", sn))
    }
    if (length(errors) > 0)
        errors
    else
        TRUE
}

setValidity("MyGene", validMyGeneObject)

setGeneric(".request.path", signature=c("mygene"),
           function(mygene, path, method=c("GET", "POST"), params=list()) standardGeneric(".request.path"))

setMethod(".request.path", c(mygene="MyGene"), function(mygene, path, method=c("GET", "POST"), params=list()) {
    url <- paste(mygene@base.url, path, sep="")
    reqmethod <- switch(method, GET=GET, POST=POST, match.fun(method))
    res <- reqmethod(url, query=params, config=add_headers(c(`User-Agent`=mygene@agent)))
    if (res$status_code != 200)
        stop("Request returned unexpected status code ", res$status_code)
    content(res, "text")
})

.request.path.json <- function(..., fromJSON.args=list()) {
    fromJSON.args <- as.list(fromJSON.args)
    fromJSON.args$txt <- .request.path(...)
    do.call(fromJSON, fromJSON.args)
}

.request.path.repeated <- function(mygene, path, vecparams, method="POST", ..., params=list(), fromJSON.args=list()) {
    fromJSON.args$simplifyDataFrame <- FALSE
    vecparams.split <- .transpose.nested.list(lapply(vecparams, .splitBySize, maxsize=mygene@step))
    vecparams.splitcollapse <- lapply(vecparams.split, lapply, .collapse)
    n <- length(vecparams.splitcollapse)
    reslist <- vector("list", n)
    i <- 1
    fjargs <- list(simplifyDataFrame=FALSE)
    repeat {
        params.i <- c(params, vecparams.splitcollapse[[i]])
        reslist[[i]] <- .request.path.json(mygene=mygene, path=path, method=method, ...,
                                           params=params.i, fromJSON.args=fromJSON.args)
        ## This avoids an extra sleep after the last fragment
        if (i == n)
            break()
        Sys.sleep(mygene@delay)
        i <- i+1
    }
    return(do.call(c, reslist))
}

setMethod("metadata", c(x="MyGene"), function(x, ...) {
    .request.path.json(x, "/metadata", "GET")
})

available.fields <- function(mygene) {
    metadata(mygene)$available_fields
}

setGeneric("getGene", signature=c("mygene"),
           function(geneid, fields = c("symbol","name","taxid","entrezgene"), ..., return.as=c("JSON", "text"), mygene) standardGeneric("getGene"))

setMethod("getGene", c(mygene="MyGene"), function(geneid, fields = c("symbol","name","taxid","entrezgene"), ..., return.as=c("JSON", "text"), mygene) {
    return.as <- match.arg(return.as)
    params <- list(...)
    params$fields <- .collapse(fields)
    res <- .request.path(mygene, paste("/gene/", geneid, sep=""), "GET", params)
    switch(return.as,
           JSON=fromJSON(res),
           text=res)
})

## If nothing is passed for the mygene argument, just construct a
## default MyGene object and use it.
setMethod("getGene", c(mygene="missing"), function(geneid, fields = c("symbol","name","taxid","entrezgene"),
                       ..., return.as=c("JSON", "text"), mygene) {
    mygene <- MyGene()
    callGeneric(geneid, fields, ..., return.as=return.as, mygene=mygene)
})

setGeneric("getGenes", signature=c("mygene"),
           function(geneids, fields = c("symbol","name","taxid","entrezgene"), ...,
                    return.as = c("DataFrame", "data.frame", "records", "text"), mygene)
           standardGeneric("getGenes"))

setMethod("getGenes", c(mygene="MyGene"), function(geneids, fields = c("symbol","name","taxid","entrezgene"), ..., return.as = c("DataFrame", "data.frame", "records", "text"), mygene) {
    return.as <- match.arg(return.as)

    ## It's not good enihgh to do multiple requests and concatenate
    ## their texts, since that will result in multiple lists. So we
    ## get the list of records and reserialze it back to JSON text.
    if (return.as == "text") {
        res <- callGeneric(geneids, fields, ..., return.as="records", mygene=mygene)
        return(toJSON(res, pretty=TRUE))
    }
    ## "DataFrame" is the same as "data.frame" only we convert to the
    ## IRanges class DataFrame and we convert "list" columns to "List"
    ## stances.
    else if (return.as == "DataFrame") {
        res <- callGeneric(geneids, fields, ..., return.as="data.frame", mygene=mygene)
        return(.df2DF(res))
    }
    ## Get the records, then call jsonlite:::simplify to convert to a
    ## data.frame
    else if (return.as == "data.frame") {
        res <- callGeneric(geneids, fields, ..., return.as="records", mygene=mygene)
        return(jsonlite:::simplify(
            res,
            simplifyDataFrame=TRUE,
            ## These other simplifications should already be done
            simplifyVector=FALSE,
            simplifyMatrix=FALSE,
            simplifyDate=FALSE))
    }
    ## Base case: return.as == "records". Return the top level record list.
    else {
        params <- list(...)
        params$fields <- .collapse(fields)
        vecparams <- list(ids=geneids)
        .request.path.repeated(mygene, "/gene/", vecparams=vecparams, params=params)
    }
})

setMethod("getGenes", c(mygene="missing"), function(geneids, fields = c("symbol","name","taxid","entrezgene"),
                        ..., return.as = c("DataFrame", "data.frame", "records", "text"), mygene) {
    mygene <- MyGene()
    callGeneric(geneids, fields, ..., return.as=return.as[1], mygene=mygene)
})

## TODO: Delete below here after migrating everything to S4
>>>>>>> other

mygene<-setRefClass("mygene",  fields=c('Url', 'delay', 'step', 'params', 'list','li', 'value', 'geneid', 'geneids', 'fields',
        'query_fn', 'query_li', 'qr', 'q', 'qterms') , methods =list(

    initialize=function(Url='http://mygene.info/v2'){
        .self$Url<<-Url
        .self$delay<<-1
        .self$step<<-1000},

    .pop=function(list, item, default_value=NULL){
        if (is.null(list[[item]])){
            return(default_value)}
        else{
            value <<- list[[item]]
            return(value)}},

    .get=function(Url, params=list()){
        debug <- .pop(params,'debug', FALSE)
        params['debug']<<-NULL
        return_raw <- .pop(params,'return_raw', FALSE)
        params['return_raw']<<-NULL

        headers<-c('User-Agent' = sprintf('R-httr_mygene.R/httr.%s', version))
        if (exists('params')){
            if (debug){
                return(content(GET(Url, query=params, verbose())))}
            else{
                res <- GET(Url, query=params, config=add_headers(headers))
                if (res$status_code ==200){
                    if (return_raw){
                      return(content(res, 'text'))}
                    else {
                      return(fromJSON(content(res, 'text')))}}
                else{print(res)}}}},

    .post=function(Url, params=list()){
<<<<<<< local
        
=======

>>>>>>> other
        debug <- .pop(params,'debug', FALSE)
        params['debug']<<-NULL
        return_raw <- .pop(params,'return_raw', FALSE)
        params['return_raw']<<-NULL

        headers<-c('Content-Type'= 'application/x-www-form-urlencoded',
            'User-Agent' = sprintf('R-httr_mygene.R/httr.%s', version))
        if (exists('params')){
            if (debug){
                return(POST(Url, body=params, config=list(add_headers(headers)), verbose()))}
            else{
                res <- POST(Url, body=params, config=list(add_headers(headers)))
                if (res$status_code == 200){
                    if (return_raw){
                        return(content(res, 'text'))}
                    else {
                      out<-content(res, 'text')
                        return(fromJSON(out, simplifyDataFrame=F))}}
                else{print(res)}}}},

    .format_list=function(list) {
        out<-paste(list, sep = "", collapse = ",")
        return(out)},

    .repeated_query=function(query_fn, query_li, params, verbose=TRUE){
        result<-list()
        ql<-length(query_li)
        if (ql <= .self$step){
            #No need to do series of batch queries, turn off verbose output
            verbose = FALSE}

        for (i in seq(1, ql, by = .self$step)){
            is_last_loop <- (i+.self$step) >= ql
            if (verbose){
                sprintf('querying %f-%f...', (i+1), min((i+.self$step), ql))}
            query_result<-query_fn((query_li[i: min(ql, (i+.self$step))]), params)
            qr<<-append(result, query_result)}
            if (!is_last_loop & .self$delay){
                sys.sleep(.self$delay)}
            if (verbose){
                cat('done.\n')}
            return(qr)
            },

    metadata=function(...){
        params<<-list(...)
        .url<-paste(.self$Url, '/metadata', sep = "")
        return(.self$.get(.url, params))},

    getgene=function(geneid, fields = 'symbol,name,taxid,entrezgene', ...){
        # '''Return the gene object for the given geneid.
        #        This is a wrapper for GET query of "/gene/<geneid>" service.
        #          @param geneid: entrez/ensembl gene id
        #          @param fields: fields to return, a list of a comma-sep string
        #                         if fields=="all", all available fields are returned.
        #          @param species: optionally, you can pass comma-separated species names
        #                           or taxonomy ids

        #        Ref: http://mygene.info/doc/annotation_service.html
        #     '''
        if (exists('fields')){
            params <<- list(...)
            params[['fields']]<<-fields
            params<<- lapply(params, function(x) {str(x);.self$.format_list(x)})
        }
        .url<-paste(.self$Url, '/gene/', geneid, sep = "")
        return(.self$.get(.url, params))},

    .transpose.nested.list=function(li) {
      ## Assumes that inner names of each element are the same
      inner.names <- names(li[[1]])
      setNames(lapply(inner.names, function(i) List(lapply(li, `[[`, i))), inner.names)},
<<<<<<< local
      
=======

>>>>>>> other
    .getgenes_inner=function(geneids, params){
        params[['ids']]<<-.self$.format_list(geneids)
        .url<-paste(.self$Url, '/gene/', sep = "")
        return(.self$.post(.url, params))},


    getgenes=function(geneids, fields = 'symbol,name,taxid,entrezgene', ...){
        # Return the list of gene object for the given list of geneids.
     #           This is a wrapper for POST query of "/gene" service.
     #             @param geneids: a list or comm-sep entrez/ensembl gene ids
     #             @param fields: fields to return, a list of a comma-sep string
     #                            if fields=="all", all available fields are returned.
     #             @param species: optionally, you can pass comma-separated species names
     #                              or taxonomy ids
     #             @param filter: alias for fields

     #          Ref: http://mygene.info/doc/annotation_service.html

        if (exists('fields')){
            params <<- list(...)
            params[['fields']]<<-fields
            params <<- lapply(params, function(x) {str(x);.self$.format_list(x)})
        }
        verbose <- .pop(params,'verbose', TRUE)
        params['verbose']<<-NULL
<<<<<<< local
        return.as.list <- .pop(params,'return.as.list', FALSE)
        params['return.as.list']<<-NULL
=======
>>>>>>> other
        out<-.self$.repeated_query(.self$.getgenes_inner, geneids, params)
<<<<<<< local
        df <- DataFrame(.self$.transpose.nested.list(out))
        if (return.as.list){return(out)}
        else{return(df)}
        },
=======
        return(out)},
>>>>>>> other

    query=function(q, ...){
        #         Return  the query result.
        #         This is a wrapper for GET query of "/query?q=<query>" service.
        #         @param fields: fields to return, a list of a comma-sep string
        #                         if fields=="all", all available fields are returned.
        #         @param species: optionally, you can pass comma-separated species names
        #                           or taxonomy ids. Default: human,mouse,rat.
        #         @param size:   the maximum number of results to return (with a cap
        #                           of 1000 at the moment). Default: 10.
        #         @param skip:    the number of results to skip. Default: 0.
        #         @param sort:    Prefix with "-" for descending order, otherwise in ascending order.
        #                         Default: sort by matching scores in decending order.
        #         @param entrezonly:  if True, return only matching entrez genes, otherwise, including matching
        #                              Ensemble-only genes (those have no matching entrez genes).

        #         Ref: http://mygene.info/doc/query_service.html

        params<<-list(...)
        params[['q']] <<- q
        .url<-paste(.self$Url, '/query/', sep = "")
        return(.self$.get(.url, params))},

    .querymany_inner=function(qterms, params){
        params[['q']]<<-.self$.format_list(qterms)
        .url<-paste(.self$Url, '/query/', sep = "")
        return(.self$.post(.url, params))},

    querymany=function(qterms, scopes=NULL, ...){
            #     Return the batch query result.
            #     This is a wrapper for POST query of "/query" service.

            #     @param qterms: a list of query terms, or a string of comma-separated query terms.
            #     @param scopes:  type of types of identifiers, either a list or a comma-separated fields to specify type of
            #                    input qterms, e.g. "entrezgene", "entrezgene,symbol", ["ensemblgene", "symbol"]
            #                    refer to "http://mygene.info/doc/query_service.html#available_fields" for full list
            #                    of fields.
            #     @param fields: fields to return, a list of a comma-sep string
            #                     if fields=="all", all available fields are returned.
            #     @param species: optionally, you can pass comma-separated species names
            #                       or taxonomy ids. Default: human,mouse,rat.
            #     @param entrezonly:  if True, return only matching entrez genes, otherwise, including matching
            #                          Ensemble-only genes (those have no matching entrez genes).

            #     @param returnall:   if True, return a dict of all related data, including dup. and missing qterms
            #     @param verbose:     if True (default), print out infomation about dup and missing qterms

            #     Ref: http://mygene.info/doc/query_service.html

        params<<-list(...)
        if (exists('scopes')){
                params[['scopes']] <<- .self$.format_list(scopes)
            if ('scope' %in% params){
                #allow scope for back-compatibility
                params[['scopes']] <<- .self$.format_list(params[['scope']])}
            if ('fields' %in% params){
                params[['fields']] <<- .self$.format_list(params[['fields']])}
            if ('species' %in% params){
                params[['species']] <<- .self$.format_list(params[['species']])}
        returnall <- .pop(params,'returnall', FALSE)
        params['returnall']<<-NULL
        verbose <- .pop(params,'verbose', TRUE)
        params['verbose']<<-NULL
        return.as.list <- .pop(params,'return.as.list', FALSE)
        params['return.as.list']<<-NULL
<<<<<<< local
        
=======

>>>>>>> other
        li_missing <-list()
        li_query <-list()
        li_cnt <-list()
        li_dup <-list()
        out<-.self$.repeated_query(.self$.querymany_inner, qterms, params, verbose=verbose)
<<<<<<< local
        
=======

>>>>>>> other
        df <- DataFrame(.self$.transpose.nested.list(out))
<<<<<<< local
      
=======

>>>>>>> other
        for (hits in out){
          if (is.null(hits$notfound)){
            li_query<-append(li_query, hits[['query']])}
          else if (hits$notfound) {
            li_missing<-append(li_missing, hits[['query']])}}
        if (verbose){
          cat("Finished\n")}
        #check dup hits
        li_cnt<-as.list(table(as.character(li_query)))
        for (hits in li_cnt){
          if (li_cnt[[hits]] > 1){
            li_dup<-append(li_dup, li_cnt[hits])}}
<<<<<<< local
        
=======

>>>>>>> other
        if (verbose){
          if (exists('li_dup')){
            sprintf('%f input query terms found dup hits:   %s', length(li_dup), li_dup)}
          if (exists('li_missing')){
            sprintf('%f input query terms found dup hits:   %s', length(li_missing), li_missing)}}
        if (returnall){
          return(list('out'= df, 'dup'=li_dup, 'missing'=li_missing))}
        if (return.as.list){
          return(out)
        }
        else {
          if (verbose & (exists('li_dup') | exists('li_missing'))){
            cat('Pass returnall=TRUE to return lists of duplicate or missing query terms.\n')
            return(df)}}}}
        ))


mg.getgene<-function(geneid, fields = 'symbol,name,taxid,entrezgene', ...){
    mg<-mygene$new()
    return(mg$getgene(geneid=geneid, fields=fields, ...))
}
mg.getgenes<-function(geneids, fields = 'symbol,name,taxid,entrezgene', ...){
    mg<-mygene$new()
    return(mg$getgenes(geneids=geneids, fields=fields, ...))
}
mg.query<-function(q, ...){
    mg<-mygene$new()
    return(mg$query(q=q, ...))
}
mg.querymany<-function(qterms, scopes=NULL, ...){
    mg<-mygene$new()
    return(mg$querymany(qterms=qterms, scopes=scopes, ...))
}
mg.metadata<-function(...){
    mg<-mygene$new()
<<<<<<< local
    return(mg$metadata(...))}=======
    return(mg$metadata(...))}
>>>>>>> other
